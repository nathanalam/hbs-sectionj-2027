---
import Layout from '../layouts/MainLayout.astro';
import { readdir } from 'node:fs/promises';

const imagePath = 'public/assets/hbs_classcard_photos';
let members = [];
try {
  const files = await readdir(imagePath);
  members = files.filter(f => f.endsWith('.jpg')).map(file => {
      const name = file
          .replace('.jpg', '')
          .split('_')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');
      return {
          id: file.replace('.jpg', ''),
          name,
          imageUrl: `/assets/hbs_classcard_photos/${file}`
      };
  });
} catch (e) {
  console.error("Error reading directory", e);
}
---

<Layout>
    <div class="bg-white p-6 md:p-8 rounded-lg shadow-lg">
        <h2 class="text-3xl font-bold text-gray-800 mb-4">Section J Alignment Chart</h2>

        <div class="mb-6 bg-gray-50 p-4 rounded border border-gray-200">
             <h3 class="text-xl font-bold mb-2">How it works</h3>
             <p class="mb-2">
                Drag and drop section members from the roster onto the alignment chart.
                Position them anywhere on the grid to represent their moral and ethical alignment
                (Lawful/Neutral/Chaotic vs. Good/Neutral/Evil).
             </p>
             <p class="text-sm">
                <a href="https://en.wikipedia.org/wiki/Alignment_(Dungeons_%26_Dragons)" target="_blank" class="text-hbs-crimson hover:underline">
                    Learn more about Alignment Charts &rarr;
                </a>
             </p>
        </div>

        <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-4">
             <div class="space-x-2">
                 <button id="reset-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded transition">
                    Reset Board
                 </button>
                 <button id="share-btn" class="bg-hbs-crimson hover:bg-red-700 text-white font-semibold py-2 px-4 rounded transition">
                    Copy Share Link
                 </button>
             </div>
             <div id="status-msg" class="text-sm text-gray-600 hidden font-bold"></div>
        </div>

        <div class="flex flex-col md:flex-row h-[800px] border border-gray-300 rounded overflow-hidden select-none">
            <!-- Sidebar for Unassigned / Bench -->
            <div class="w-full md:w-1/4 h-1/3 md:h-full bg-gray-100 border-b md:border-b-0 md:border-r border-gray-300 flex flex-col">
                <div class="p-3 bg-gray-200 font-bold text-center border-b border-gray-300 shadow-sm z-10">
                    Roster
                </div>
                <div id="bench" class="flex-1 p-2 overflow-y-auto content-start grid grid-cols-4 sm:grid-cols-6 md:grid-cols-3 lg:grid-cols-4 gap-2">
                    <!-- Members injected here -->
                </div>
            </div>

            <!-- The Chart Area -->
            <div id="chart-container" class="relative w-full md:w-3/4 h-2/3 md:h-full bg-white overflow-hidden cursor-crosshair">
                <!-- Grid Background -->
                <div class="absolute inset-0 grid grid-cols-3 grid-rows-3 pointer-events-none">
                    <div class="border-r border-b border-gray-200 flex items-center justify-center"><span class="opacity-10 font-black text-3xl md:text-5xl uppercase text-center transform -rotate-12">Lawful<br>Good</span></div>
                    <div class="border-r border-b border-gray-200 flex items-center justify-center"><span class="opacity-10 font-black text-3xl md:text-5xl uppercase text-center transform -rotate-12">Neutral<br>Good</span></div>
                    <div class="border-b border-gray-200 flex items-center justify-center"><span class="opacity-10 font-black text-3xl md:text-5xl uppercase text-center transform -rotate-12">Chaotic<br>Good</span></div>

                    <div class="border-r border-b border-gray-200 flex items-center justify-center"><span class="opacity-10 font-black text-3xl md:text-5xl uppercase text-center transform -rotate-12">Lawful<br>Neutral</span></div>
                    <div class="border-r border-b border-gray-200 flex items-center justify-center"><span class="opacity-10 font-black text-3xl md:text-5xl uppercase text-center transform -rotate-12">True<br>Neutral</span></div>
                    <div class="border-b border-gray-200 flex items-center justify-center"><span class="opacity-10 font-black text-3xl md:text-5xl uppercase text-center transform -rotate-12">Chaotic<br>Neutral</span></div>

                    <div class="border-r border-gray-200 flex items-center justify-center"><span class="opacity-10 font-black text-3xl md:text-5xl uppercase text-center transform -rotate-12">Lawful<br>Evil</span></div>
                    <div class="border-r border-gray-200 flex items-center justify-center"><span class="opacity-10 font-black text-3xl md:text-5xl uppercase text-center transform -rotate-12">Neutral<br>Evil</span></div>
                    <div class="flex items-center justify-center"><span class="opacity-10 font-black text-3xl md:text-5xl uppercase text-center transform -rotate-12">Chaotic<br>Evil</span></div>
                </div>

                <div class="absolute inset-0 flex flex-col justify-between pointer-events-none px-2 py-1">
                    <div class="flex justify-between w-full opacity-30 text-xs font-bold uppercase">
                        <span>Lawful</span>
                        <span>Chaotic</span>
                    </div>
                     <div class="flex justify-between w-full opacity-30 text-xs font-bold uppercase">
                        <span>Good</span>
                    </div>
                    <div class="flex justify-between w-full opacity-30 text-xs font-bold uppercase">
                        <span>Evil</span>
                    </div>
                </div>

                <!-- Pucks will be placed here -->
            </div>
        </div>
    </div>

    <template id="puck-template">
        <div class="puck cursor-grab active:cursor-grabbing w-10 h-10 md:w-12 md:h-12 rounded-full overflow-hidden shadow-md border-2 border-white hover:border-hbs-crimson hover:shadow-lg transition-transform hover:scale-110 z-20 shrink-0" draggable="false">
            <img src="" alt="" class="w-full h-full object-cover pointer-events-none">
        </div>
    </template>

    <script define:vars={{ members }}>
        // Pass members to client side
        window.allMembers = members;
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const bench = document.getElementById('bench');
            const chart = document.getElementById('chart-container');
            const puckTemplate = document.getElementById('puck-template');
            const resetButton = document.getElementById('reset-btn');
            const shareButton = document.getElementById('share-btn');
            const statusMsg = document.getElementById('status-msg');

            let pucks = {}; // Map id -> element
            let state = {}; // Map id -> { container: 'bench' | 'chart', x: %, y: % }
            let isDragging = false;
            let currentDrag = null;
            let dragOffset = { x: 0, y: 0 };

            // Initialize
            function init() {
                // 1. Load state from URL param 's' if present
                const urlParams = new URLSearchParams(window.location.search);
                const stateParam = urlParams.get('s');

                if (stateParam) {
                    try {
                        state = JSON.parse(atob(stateParam));
                    } catch (e) {
                        console.error('Failed to parse state from URL', e);
                        state = loadFromLocalStorage() || {};
                    }
                } else {
                    state = loadFromLocalStorage() || {};
                }

                // 2. Create pucks
                window.allMembers.forEach(member => {
                    const puck = createPuck(member);
                    pucks[member.id] = puck;

                    const memberState = state[member.id];
                    if (memberState && memberState.container === 'chart') {
                        placeInChart(puck, memberState.x, memberState.y);
                    } else {
                        placeInBench(puck);
                    }
                });
            }

            function createPuck(member) {
                const clone = puckTemplate.content.cloneNode(true);
                const el = clone.querySelector('.puck');
                el.dataset.id = member.id;
                el.title = member.name;
                el.querySelector('img').src = member.imageUrl;
                el.querySelector('img').alt = member.name;

                // Add mouse events for dragging
                el.addEventListener('mousedown', onMouseDown);
                // Touch events for mobile
                el.addEventListener('touchstart', onTouchStart, {passive: false});

                return el;
            }

            function placeInBench(puck) {
                // Reset styles for bench
                puck.style.position = '';
                puck.style.top = '';
                puck.style.left = '';
                puck.style.transform = '';
                bench.appendChild(puck);
            }

            function placeInChart(puck, xPercent, yPercent) {
                puck.style.position = 'absolute';
                puck.style.left = `${xPercent}%`;
                puck.style.top = `${yPercent}%`;
                puck.style.transform = 'translate(-50%, -50%)';
                chart.appendChild(puck);
            }

            function loadFromLocalStorage() {
                const s = localStorage.getItem('alignment_chart_state');
                return s ? JSON.parse(s) : null;
            }

            function saveState() {
                localStorage.setItem('alignment_chart_state', JSON.stringify(state));
            }

            // Drag and Drop Logic
            function startDrag(el, clientX, clientY) {
                isDragging = true;
                currentDrag = el;

                // Calculate offset from the center of the puck
                const rect = currentDrag.getBoundingClientRect();
                dragOffset.x = clientX - (rect.left + rect.width / 2);
                dragOffset.y = clientY - (rect.top + rect.height / 2);

                // Move to body to allow free dragging across containers
                currentDrag.style.position = 'fixed';
                currentDrag.style.zIndex = '1000';
                currentDrag.style.transform = 'translate(-50%, -50%)'; // Center on cursor
                currentDrag.style.width = rect.width + 'px'; // maintain size
                currentDrag.style.height = rect.height + 'px';

                updateDragPosition(clientX, clientY);
                document.body.appendChild(currentDrag);
            }

            function onMouseDown(e) {
                e.preventDefault();
                startDrag(e.currentTarget, e.clientX, e.clientY);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }

            function onTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                startDrag(e.currentTarget, touch.clientX, touch.clientY);
                document.addEventListener('touchmove', onTouchMove, {passive: false});
                document.addEventListener('touchend', onTouchEnd);
            }

            function onMouseMove(e) {
                if (!isDragging) return;
                updateDragPosition(e.clientX, e.clientY);
            }

            function onTouchMove(e) {
                if (!isDragging) return;
                e.preventDefault(); // prevent scrolling
                const touch = e.touches[0];
                updateDragPosition(touch.clientX, touch.clientY);
            }

            function updateDragPosition(cx, cy) {
                if (!currentDrag) return;
                currentDrag.style.left = cx + 'px';
                currentDrag.style.top = cy + 'px';
            }

            function endDrag(clientX, clientY) {
                 if (!isDragging) return;
                isDragging = false;

                const puckId = currentDrag.dataset.id;
                const chartRect = chart.getBoundingClientRect();

                // Check if dropped inside chart
                if (
                    clientX >= chartRect.left &&
                    clientX <= chartRect.right &&
                    clientY >= chartRect.top &&
                    clientY <= chartRect.bottom
                ) {
                    // Calculate percentage position
                    const relativeX = clientX - chartRect.left;
                    const relativeY = clientY - chartRect.top;
                    const xPercent = (relativeX / chartRect.width) * 100;
                    const yPercent = (relativeY / chartRect.height) * 100;

                    state[puckId] = { container: 'chart', x: xPercent, y: yPercent };

                    // Convert fixed back to absolute within chart
                    currentDrag.style.position = 'absolute';
                    currentDrag.style.zIndex = '';
                    currentDrag.style.left = `${xPercent}%`;
                    currentDrag.style.top = `${yPercent}%`;
                    currentDrag.style.width = ''; // reset width/height to CSS
                    currentDrag.style.height = '';
                    currentDrag.style.transform = 'translate(-50%, -50%)';
                    chart.appendChild(currentDrag);
                } else {
                    // Dropped outside chart -> Bench
                    state[puckId] = { container: 'bench' };
                    currentDrag.style.zIndex = '';
                    currentDrag.style.width = '';
                    currentDrag.style.height = '';
                    placeInBench(currentDrag);
                }

                saveState();
                currentDrag = null;
            }

            function onMouseUp(e) {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                endDrag(e.clientX, e.clientY);
            }

            function onTouchEnd(e) {
                document.removeEventListener('touchmove', onTouchMove);
                document.removeEventListener('touchend', onTouchEnd);
                const touch = e.changedTouches[0];
                endDrag(touch.clientX, touch.clientY);
            }

            // Buttons
            resetButton.addEventListener('click', () => {
                if(confirm('Reset all positions?')) {
                    state = {};
                    saveState();
                    // Move all to bench
                    Object.values(pucks).forEach(puck => placeInBench(puck));
                    // Clear URL params
                    window.history.replaceState({}, '', window.location.pathname);
                }
            });

            shareButton.addEventListener('click', () => {
                const stateStr = btoa(JSON.stringify(state));
                const url = new URL(window.location.href);
                url.searchParams.set('s', stateStr);

                navigator.clipboard.writeText(url.toString()).then(() => {
                    statusMsg.textContent = 'Link copied!';
                    statusMsg.classList.remove('hidden');
                    setTimeout(() => statusMsg.classList.add('hidden'), 2000);

                    // Also update address bar without reload
                    window.history.pushState({path:url.toString()},'',url.toString());
                }).catch(err => {
                    console.error('Failed to copy', err);
                    statusMsg.textContent = 'Failed to copy';
                    statusMsg.classList.remove('hidden');
                });
            });

            // Start
            init();
        });
    </script>
</Layout>
